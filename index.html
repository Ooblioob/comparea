<!DOCTYPE html>
<meta charset="utf-8">
<title>Countries by Area</title>
<style>
.shape0 { fill: red; }
.shape1 { fill: blue; }
html,body,#svg-container{
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow-y: hidden;  /* why!? */
}
</style>

<script src="d3.min.js"></script>
<script src="queue.min.js"></script>
<script src="topojson.min.js"></script>
<script src="d3.geo.projection.min.js"></script>
<script src="shapely.min.js"></script>
<script src="danvk.js"></script>

<body>

<div id="svg-container"></div>

<script>

var width = document.getElementById('svg-container').offsetWidth,
    height = document.getElementById('svg-container').offsetHeight;

var svg = d3.select("#svg-container").append("svg")
    .attr("width", '100%')
    .attr("height", '100%');

function projectionForCountry(feature) {
  var centroid = d3.geo.centroid(feature);
  var lon = centroid[0], lat = centroid[1];
  var proj = d3.geo.albers()
    .center([0, lat])
    .rotate([-lon, 0])
    .parallels([0, 60])
    .scale(1000)
    .translate([width / 2, height / 2]);
  return proj;
}

function transform(d) {
  return 'translate(' + [d.dx,d.dy] + ')';
}

var drag = d3.behavior.drag()
  .on('drag', function(d, i) {
      d.dx += d3.event.dx;
      d.dy += d3.event.dy;
      d3.select(this).attr('transform', transform);
  });

var zoom = d3.behavior.zoom().on('zoom', function() {
  var sx = zoom.scale(), sy = sx, cx = width/2, cy = height/2;

  // See http://stackoverflow.com/questions/6711610/how-to-set-transform-origin-in-svg
  var matrix = [sx, 0, 0, sy, cx-sx*cx, cy-sy*cy];
  
  d3.select('.container').attr('transform', 'matrix(' + matrix + ')')
});

queue()
    .defer(d3.json, "world-110m.json")
    .defer(d3.csv, "codes.csv")
    .defer(d3.csv, "areas.csv")
    .defer(d3.tsv, "world-country-names.tsv")
    .defer(d3.csv, "continents.csv")
    .await(function(error, world, codes, areas, names, continents) {
          nameById = {},
          areaById = {},
          idByAlpha = {},
          continentById = {};
      continents.forEach(function(d) { continentById[d.id] = d.continent; });
      names.forEach(function(d) { nameById[d.id] = d.name; });
      codes.forEach(function(d) { idByAlpha[d.a3] = d.n3; });
      areas.forEach(function(d) { areaById[idByAlpha[d.code]] = +d.area; });
      topojson_features = topojson.feature(world, world.objects.countries).features;
      var subset_features = [topojson_features[0], topojson_features[1]];
      var paths = subset_features.map(function(feature) {
        var proj = projectionForCountry(feature);
        return d3.geo.path().projection(proj);
      });

      path = paths[0];
      subset_features.forEach(function(d) { d.dx = 0; d.dy = 0; });

      svg.append('g')
        .attr('class', 'container')
        .selectAll('.shape1')
        .data(subset_features)
      .enter().append('g')
        .attr('class', 'draggable').append('path')
          .attr('class', function(d, i) { return 'shape shape' + i; })
          .attr('d', function(d, i) { return paths[i](d); });

      svg.selectAll('.draggable').call(drag);
      svg.call(zoom);
    });

</script>
</body>
